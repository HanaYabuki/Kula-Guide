# 函数
> 函数 是 Kula 语言在语言层面的一些基本操作。

我们看到：
1. 除第一行的注释
2. 程序中包含一条语句，他调用了一次内置函数 `println(x:Any): None`。

下面我们会讲解 Kula 语言中的 **函数**。

## 描述格式
Kula 语言的内置函数皆适用以下的描述格式：
```
<函数名> ( [<参数>:<参数类型>][,] ) : <返回值类型>
```

比如，输出函数的格式是：
```
println(x: Any): None
```
也就是说，我们可以填入任何形式的变量。    
变量输出后，不会有任何后效。

> 事实上，`print`系函数是特殊的。    
> 你可以在 `println` 里填写不限制个数的参数，他们会被依次输出在控制台内，最终换行。

再比如，四则运算函数的格式是：
```
plus(x: Num, y:Num): Num
minus(x: Num, y:Num): Num
times(x: Num, y:Num): Num
div(x: Num, y:Num): Num
```
也就是说，我们可以填入 **2个** `Num` 类型作为参数，函数运行的结果相当于 **1个** `Num`，也就是 *四则运算* 的结果。

现在，四则函数的函数名也可以用运算符字符来代替，例如 `+(1,2)` 等价于 `plus(1,2)`

> 更多的内置函数会介绍在 **第二部分的内置函数表** 里，这里不做枚举的介绍。

## 命名空间 (Pre-0.4 以后的版本加入)
kula 在 Pre-0.4 以后的版本对内置函数引入了命名空间，他们可以分隔函数名称，避免污染命名。不在全局空间的函数在调用以前需要声明其命名空间。

例如，前文提到的 `println` 函数，即属于 `Shell` 命名空间。当我们调用 `println` 时，需要带上命名空间名称和 `.` 点运算符。

```kula
# 不再正确，因为全局命名中并不含有 println 这一变量
println("hello_world");
# 正确
Shell.println("hello_world");
```

> 实际上，命名空间只是一个内置的 `Map` 数据结构。不同的是，这个 Map 不能被覆盖。

这样的设计可以避免全局内的函数过多，导致编码过程中的命名冲突。也可以很好的归类函数。

### 语法太长了，能不能简化一下？
在 Pre-0.4 的更新中，加入命名空间的同时，也加入了 `unpack(namespace: Map): None` 函数，可以填入一个命名空间，将该命名空间解包。  
解包后，这个命名空间中的变量就会被释放到全局环境中。
```kula
unpack(Shell);
println("hello_world");
```

同时，也引入了 `unpackAll(): None` 函数，将所有的命名空间都释放到全局。(`new` 系函数会被命名为 `newXxx` 如 `newMap` `newArray`)  
当然并不建议这样做，虽然它本身不会形成冲突。
```kula
unpackAll();
println("hello_world");
```

## 调用
函数的调用遵循以下格式：
```
<函数名> ( [参数][,] )
```
函数在调用后，实际结果当作 *函数的返回值* 处理。

例如：
```kula
a = 10;
a = times(a, a);
```
即为将 `a` 乘方。

> 注意：  
> + 函数的参数个数是有限制的。
> + 函数的参数有类型约束，填入不规范的类型可能会造成异常。
> + 关闭类型检查可以提高程序运行的效率，但是当出现运行异常时，错误会很难被定位。

## 作用
函数一般有两个作用：
+ 操作值
+ 造成某种影响

举例子，比如 **四则运算** 函数，是将 *值* 处理为 *值*，即为 **操作值**
```kula
a = 114;
b = 514;
sum = plus(a, b);
```

再比如，输出函数`println`，没有处理其参数，而是将填入的内容 *输出到屏幕上*。   
这个操作和 *值* 是无关的，而是所谓的 **造成了某种影响**
```kula
println(114514);
```

> 当然，函数可以同时具有这两个特性。但是内置函数为了保证功能的原子性，一般不会这样~。

!> 看到这里，建议先停下来，扫读一遍 **第二部分** 的函数表 (除数据结构部分)。    
熟悉基本的函数会让你对 Kula 的编码思路更熟悉。

## 将函数的运行结果视为值
> 如果你能轻松地理解这个概念，那么学习编程语言对你来说则不是一件难事！

如果一个函数的返回值不是 `None`，即 *有返回值*，那么这个函数的运行结果就可以被视为一个值。

看下面的例子：
```kula
Shell.println(times(100, 5));
```
这段程序会输出一个 `500`。    
因为 `println` 接收到的其实是 `times` 函数的运行结果，也就是一个 `Num`。

我们还可以来点儿更复杂的：
```kula
a = 114;
b = 514;
Shell.println(
    Str.concat(
        "sum = ", 
        Str.toStr(plus(a, b))
    )
);
```

这段程序会输出 `sum = 628`。    
因为 `println` 接收到的参数是 `concat` (即连接两个字符串) 的结果，而 `concat` 的参数是 `"sum = "` 和 `toStr` 的结果。   
其中，`println` 接收到的是一个 `Str` 类型的值，它是由 `concat` 计算而来。    
`concat` 接受两个参数，分别是 结果字符串的前半段和后半段。前半段是一个常量 `"sum = "`，后半段是被 `toStr` 运算出来的。    
`toStr` 需要接收一个 `Num`，则是由四则运算函数之一的 `plus` 运算而来。

> 几乎，所有的编程语言都支持这种编码方式。

## 利用内置函数，操作数据结构
数据结构是 Kula 中仅有的 可变数据类型。对数据结构的操作要利用对应的内置函数。

```kula
langMap = Map.new();
Map.put(langMap, "java", "Bad.");
Map.put(langMap, "c#", "Good!");
Map.put(langMap, "kula", "AWESOME!!!");

if (Map.keyIn(langMap, "kula")) {
    Shell.println(Str.concat("kula is ", langMap["kula"]));
}
```

我们在使用函数操作数据结构时，数据结构本身需要作为参数传入。   
更多的内容会在后文数据结构相关内容里详细介绍，这里简单的演示用法。