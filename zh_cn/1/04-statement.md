# 语句
> 从结构角度讲，Kula 程序通常使用面向过程的方式构建。\
> 整个程序由多条语句或语法块构成。

下面将会对 Kula 语言的语句格式进行讲解。

## 值语句
```EBNF
exprStmt    =   expression ";" ;
```
是一个值表达式和一个分号构成的语句。

在该语句中，表达式会被计算，但作为计算结果的值会被丢弃。
```kula
100;
a;
foo(10, 20);
obj.key1;
arr[15];
a + b;          # 计算确实进行了，但返回值被丢弃了

(func () { print "hello"; })(); # 运行这个东西，他会打印"hello"字符串，因为计算确实进行了
```

## 赋值语句
```EBNF
exprStmt    =   expression ";" ;
expression  =   assignment
            |   ...
            ;
assignment  =   (call | IDENTIFIER) assign expression
            |   ...
            ;
```
在上一章中，我们并没有完整的讲解赋值表达式，本章将会补齐对应内容。

赋值语句分为 *左值* 和 *右值*，左值是被赋值者，右值是待计算的表达式。\
左值除了可以是一个普通的变量，也可以是一个数据容器的调用。
```kula
# 左值是变量
a := 1; # 声明赋值
a = 2;  # 更改赋值

# 左值是容器
arr[1] = 10;
obj.key1 = "value1";
# 注意：当左值不是变量时，声明赋值符号失效，等价视为更改赋值。
```

赋值语句本质上其实就是一个值语句，只不过是该语句中的值是一个**赋值表达式**。

______
!> 没写完，卡在这儿了
______

### 声明赋值
```kula
a := 100;
b := a * 114514;
```

这个语句会在**原地声明或更新**一个变量，**它不会考虑外层作用域是否已经存在这个变量**。
> **作用域**是一个新概念。暂时可以理解为：这条语句所在的空间以及更深于它的空间。

### 寻址赋值
```
a = 100;
b = "kula" + "diamond";
```

这个语句会按照名称 *更新* 一个变量。

即：
+ 如果变量名在当前作用域范围内存在，则更新这个变量的内容。
+ 如果变量名在当前作用域范围内不存在，则抛出一个错误。


自然的，如果值是一个表达式，会优先计算表达式，再将结果写入变量。
```kula
calc = a + b;  # calc 的值是 a与b的和
```

## 逻辑控制语句

### if 逻辑
```
if (<值>) { [<语句>] }
```

例如
```kula
if (age > 18) {
    print "我成年咯！";
}
```

这个语句用来控制逻辑，被视为一种 *条件分歧*。当 *值* 为真时，会执行 **大括号内的语句组**。

> 从这里我们可以看到，语句的定义是 **递归** 的！    
> 事实上，不只是语句，**值的定义也是递归的**

Kula 也支持 `else` 语法，用于处理 *不满足条件的情况* 。

例如
```kula
if (age > 18) {
    print "我成年咯！";
}
else {
    print "我没成年！";
}
```

### while 逻辑
```
while (<值>) { [<语句>] }
```

例如
```kula
while (a < 10) {
    a *= 2;
}
```

这个语句也被用来控制逻辑，被视为一种 *条件循环*。当 *值* 为 非零时，会执行 **大括号内的语句组**，之后，程序会重新跳转到 `while` 语句的开头，重新重复此过程。

在本例中，如果变量 `a` 的值小于 10，则会一直翻倍，直到超过 10 为止。

### for 逻辑
```

```

## 短路运算符

